# Ответ на Задание (Vova Zakharov)

Примечание: Я пишу с длинными тире и кавычками-«ёлочками» — это мой стиль, а не следствие использования ИИ.

> Задание проверяет понимание технологий и умение это понимание применять на практике на базе вашего существующего опыта.


> Репозиторий содержит некоторе решение некоторой задачи. И задача и решене здесь приведены
только для наглядности. Ответ на каждый вопрос принимается исключительно про ваш реальный опыт над реальным проектом.
Мы ожидаем развернутых ответов.

> Решением задания будет написание ответов на вопросы ниже. Ответ можно отправить в свободной форме.

## Аутентификация

> Для аутентификации в этом репозитории используется jwt токен. Технология известная, зарекомендовавшая себя. 
Давайте в ней усомнимся. Как минимум - в целесообразности гонять в каждом http запросе такой большой кусок данных.
Расскажите о проектах с вашим участием, где использовалась другая техника авторизации. 
Если в таких проектах вы бы могли выбирать - выбрали бы вы аутентификацию через jwt? Если да, то почему?
В каком проекте, в котором вы участвовали, вы бы наоборот, вместо jwt выбрали что-то другое и почему?

Ответ: Я не люблю JWT. В своих проектах и в проектах, где от моего решения это зависит, использую только в случае крайней необходимости (см. ниже).

Главная причина — что токен нельзя инвалидировать до истечения срока. Workaround-ы типа вести blacklist на сервере делают схему stateful и устраняют само преимущество JWT перед обычными сессиями.

Обычно ссылаюсь вот на этот flow chart (источник: [Stop using JWT for sessions, part 2: Why your solution doesn't work](http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/)).

![](jwt-flowchart.png)

Также считаю наглядной историю с [algo: none](https://github.com/beatt83/jose-swift/security/advisories/GHSA-88q6-jcjg-hvmw). Чисто эмпирически, если люди разрабатывают системы аутентификации с *такими* дырами, то нельзя быть уверенными, что там нет ещё дыр, даже если эта конкретная была залатана.

Единственный случай, когда всё-таки применял бы JWT — это если вынужден принимать токены от внешнего identity provider — Google, GitHub и т.п. Тогда JWT — де-факто стандарт, и выбора особо нет.

В применении к тестовой задачке, кажется, JWT — точно оверкилл, поэтому использовал бы обычные сессии. Примерный альтернативный код мог бы выглядеть так (в реальности, конечно, использовал бы ORM, а не просто писал голый SQL):

```typescript
const id = crypto.randomBytes(16).toString('hex');
const verifier = crypto.randomBytes(32).toString('hex');

const verifierHash = crypto.createHash('sha256').update(verifier).digest('hex');

await db.query(
  'INSERT INTO sessions (id, verifier_hash, user_login, expires_at) VALUES ($1, $2, $3, NOW() + INTERVAL \'24 hours\')',
  [id, verifierHash, user.login]
);

res.cookie('session', `${id}.${verifier}`, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict',
  maxAge: 86400000
});

const [cookieId, cookieVerifier] = req.cookies.session.split('.');
const session = await db.query(
  'SELECT * FROM sessions WHERE id = $1 AND expires_at > NOW()',
  [cookieId]
);
const cookieVerifierHash = crypto.createHash('sha256').update(cookieVerifier).digest('hex');

const valid = crypto.timingSafeEqual(
  Buffer.from(session.rows[0].verifier_hash),
  Buffer.from(cookieVerifierHash)
);
```

(Логика: база ищет только по несекретному, короткому id, а verifier никогда не индексируется и не хранится в открытом виде. Даже если хакер сможет измерить время ответа БД, он увидит только lookup по id, а секретная часть будет сравниваться уже в памяти через timingSafeEqual. Хэш верифаера защищает от утечки через SQL dump.)

При трёх инстансах бэкенда — shared БД автоматически решает вопрос привязки к конкретному инстансу. Если нужно инвалидировать сессию — просто удаляем строку.

## Идентификация

> В этом репозтории в некоторых таблицах для идентификации записи используется uuid. Эта техника удобна по нескольким параметрам.
> Сложно представить, чтобы использование uuid во всех таблицах - как стандарта - создало бы где нибудь проблему.
> Но может быть в вашей практике встречались случаи, где uuid как идентификатор стал проблемой или мог бы стать проблемой?
> Опишите где и почему.

Ответ: Не сказать, что именно проблему, но иногда я полагаюсь на внешние идентификаторы, когда основой приложения является сторонний сервис. Например, когда я пишу тг-бота, я использую в качестве идентификатора пользователя его telegram id, а не какой-то внутренний идентификатор.

Из известных проблем, UUID v4 — случайные числа, поэтому вставки в таблицу с UUID как primary key бьют в случайные позиции индекса, а не в конец. Это постоянные page splits и index bloat. При большом объёме данных и частых вставках (например, таблица событий или логов) это ощутимо бьёт по производительности. Сразу скажу, сам с таким не сталкивался, не было кейсов, где это было бы критично.

Как альтернативы: [UUID v7](https://www.rfc-editor.org/rfc/rfc9562), [ULID](https://github.com/ulid/spec) — оба начинаются timestamp, так что их можно сортировать лексиграфически, более эффективно использовать как индекс и т.п. Также можно просто использовать serial/sequence, если не нужна глобальная уникальность или защита от перебора.

## Организация кода

> В этом репозитории, серверный код сделан на базе NestJS. 
> DI, services, controllers, middleware, decorators - в этом, как и во многих других подходах есть плюсы и выгоды.
Расскажите с примерами из опыта о реальной пользе того или иного механизма организации кода лично для вас или
для вашей команды, а может быть - для компании. Если есть какой-то механим, который также - для вас, команды 
или компании наоборот - создавал сложности - тоже расскажите.

Ответ: Использовал NestJS/DDD в одном из последних проектов и, по личному ощущению, там это было оверкиллом, потому что сервис был достаточно простой. Но идея СТО в том проекте заключалась в том, что он будет расти со временем, и в какой-то момент мы поблагодарим нашу собственную прозорливость.

В принципе мне нравится, что NestJS заставляет думать о бизнес-логике и данных, а также упрощает юнит-тесты, но иногда режет глаз «магический» подход к DI. Например, ошибки circular dependency, которые вылезают только в рантайме, костыли в виде `forwardRef()` и так далее.

## Реактивность

> В этом репозитории, для интерфейса используется React. Его название связано с реактивным подходом к отрисовке
интерфейса - мы меняем состояние, а интерфейс перерисовывается в соответствии с этим. 
Сам посыл подкупает - разработчик заботится о состоянии, остальное за него делает фреймворк. 
Такой подход, конечно, помимо React реализуют и многие другие фреймворки. 
Были ли ситуации в вашем опыте, когда реактивность была не плюсом, а помехой? Если да, расскажите на примере.
Если был опыт построения рендера интерфеса на другом принципе, раскажите на каком и какие были резльтаты?
Расскажите на конкретных примерах, что вам доставляет неудобства в том, как реактивность реализована
непосредственно во фреймворке React?

Ответ: Опять же, не назову это «помехой», но вот конкретный пример: На позапрошлом проекте нам нужно было генерировать минимально реактивные HTML-отчёты, которые должны были храниться условно «вечно» на CDN. Пользователь также должен был иметь возможность скачать их и запустить на своём компьютере вне какой-либо платформы.

«Инжектить» реакт в таком случае очень неэкономично, поэтому я реализовал какие-то минимально реактивные вещи (нажал галочку — обновился график) в «ванильном» JS. Были альтернативы в виде какого-нибудь petite-vue, но опять же, было критичным обеспечить «вечность» отчёта, а зависимость от внешних библиотек — это всегда риск.

Что касается реактивности именно React, то она мне скорее нравится, чем нет. Разумеется, во Vue есть вещи, которые делать намного легче (computed-ы, watchers), и там меньше опасности «вляпаться» в какие-нибудь stale closures (например, в этой конкретной репе `useEffect` на строках 39–47 в `RoudPage.tsx` зависит от roundData, но её нет в dependencies) или бесконечные циклы рендеров, но это лечится разными методами (в первую очередь, опытом). Долгое время из-за таких «опасностей» я предпочитал Vue, но со временем пришёл к тому же выводу, что в случае с NestJS: чем меньше магии, тем лучше. В разумных пределах, конечно.